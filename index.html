<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magic Star - Final Perfect</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        
        #canvas-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        .input_video { display: none; }

        /* ÂêØÂä®ÈÅÆÁΩ© */
        #start-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 999;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: white; text-align: center; backdrop-filter: blur(5px);
        }
        #start-btn {
            margin-top: 20px; padding: 15px 40px; font-size: 18px;
            background: linear-gradient(45deg, #00d2ff, #3a7bd5);
            border: none; border-radius: 50px; color: white; cursor: pointer;
            box-shadow: 0 0 20px rgba(0, 210, 255, 0.5);
            transition: transform 0.2s;
        }
        #start-btn:hover { transform: scale(1.05); }

        /* UI */
        .ui-layer {
            position: absolute; bottom: 30px; width: 100%; 
            display: flex; justify-content: center; gap: 15px;
            z-index: 10; pointer-events: none; opacity: 0;
            transition: opacity 1s;
        }
        
        .glass-btn, input[type="text"] {
            pointer-events: auto;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff; padding: 10px 20px;
            border-radius: 30px; outline: none;
            font-size: 14px; text-align: center;
            text-transform: uppercase; letter-spacing: 1px;
        }
        .glass-btn:hover { background: rgba(255, 255, 255, 0.25); cursor: pointer; }
        #file-input { display: none; }

        /* Áä∂ÊÄÅÊåáÁ§∫Âô® */
        #status-pill {
            position: fixed; top: 20px; right: 20px; z-index: 20;
            background: rgba(0,0,0,0.6); border: 1px solid #333;
            padding: 8px 16px; border-radius: 20px;
            color: #888; font-size: 12px; display: flex; align-items: center; gap: 8px;
        }
        .dot { width: 8px; height: 8px; border-radius: 50%; background: #555; }
        .dot.active { background: #00ff88; box-shadow: 0 0 8px #00ff88; }
        .dot.error { background: #ff3333; }
    </style>
</head>
<body>

    <div id="start-overlay">
        <h1>‚ú® Magic Star Experience</h1>
        <p>ÈúÄË¶ÅÊëÑÂÉèÂ§¥ÊùÉÈôêÊù•ÊçïÊçâ‰Ω†ÁöÑÊâãÂäø</p>
        <button id="start-btn">ÂºÄÂêØ‰ΩìÈ™å</button>
    </div>

    <div id="status-pill">
        <div class="dot" id="cam-dot"></div>
        <span id="status-text">Á≠âÂæÖÂêØÂä®...</span>
    </div>

    <video class="input_video" playsinline></video>
    <div id="canvas-container"></div>

    <div class="ui-layer" id="ui-layer">
        <label for="file-input" class="glass-btn">üì∑ ‰∏ä‰º†ÁÖßÁâá</label>
        <input type="file" id="file-input" accept="image/*">
        <input type="text" id="wish-text" value="I LOVE YOU">
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        let scene, camera, renderer, composer, particles, photoMesh;
        let particlesData = [];
        const PARTICLE_COUNT = 6500; 
        let isFist = false;
        let time = 0;

        document.getElementById('start-btn').addEventListener('click', async () => {
            document.getElementById('start-overlay').style.display = 'none';
            document.getElementById('ui-layer').style.opacity = '1';
            init3DEngine(); 
            await startCameraAI();
        });

        function init3DEngine() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050510, 0.0015); 

            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 3000);
            camera.position.set(0, 0, 400);

            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ReinhardToneMapping;
            renderer.toneMappingExposure = 1.2;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.7; 
            bloomPass.strength = 0.8;
            bloomPass.radius = 0.3;
            
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            const controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.8;

            initParticles();
            calcNebulaTargets();
            animate();

            window.addEventListener('resize', onWindowResize);
        }

        function createBetterSparkle() {
            const c = document.createElement('canvas'); c.width=128; c.height=128;
            const ctx = c.getContext('2d');
            const grad = ctx.createRadialGradient(64,64,0,64,64,64);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(0.2, 'rgba(230,240,255,0.8)');
            grad.addColorStop(0.5, 'rgba(100,200,255,0.2)');
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,128,128);
            ctx.fillStyle = "rgba(255,255,255,0.8)";
            ctx.beginPath();
            ctx.moveTo(64, 20); ctx.lineTo(70, 58); ctx.lineTo(108, 64); ctx.lineTo(70, 70);
            ctx.lineTo(64, 108); ctx.lineTo(58, 70); ctx.lineTo(20, 64); ctx.lineTo(58, 58);
            ctx.fill();
            const t = new THREE.Texture(c); t.needsUpdate=true; return t;
        }

        function initParticles() {
            const geo = new THREE.BufferGeometry();
            const pos = [], cols = [], sizes = [];
            const colors = [new THREE.Color('#ffffff'), new THREE.Color('#00ffff'), new THREE.Color('#ff00ff'), new THREE.Color('#aaaaff')];

            for(let i=0; i<PARTICLE_COUNT; i++) {
                pos.push((Math.random()-0.5)*800, (Math.random()-0.5)*800, (Math.random()-0.5)*800);
                const c = colors[Math.floor(Math.random()*colors.length)];
                cols.push(c.r, c.g, c.b);
                sizes.push(Math.random() * 2.5 + 0.5);
                particlesData.push({ 
                    tx:0, ty:0, tz:0, 
                    speed: 0.02 + Math.random()*0.03, 
                    randomOffset: Math.random() * 100 
                });
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            geo.setAttribute('color', new THREE.Float32BufferAttribute(cols, 3));
            geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

            const mat = new THREE.PointsMaterial({
                size: 2.0, vertexColors: true, map: createBetterSparkle(),
                blending: THREE.AdditiveBlending, depthWrite: false, transparent: true, opacity: 0.9, sizeAttenuation: true
            });
            particles = new THREE.Points(geo, mat);
            scene.add(particles);
        }

        function calcNebulaTargets() {
            for(let i=0; i<PARTICLE_COUNT; i++) {
                const angle = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = 200 + Math.random() * 300;
                particlesData[i].tx = r * Math.sin(phi) * Math.cos(angle);
                particlesData[i].ty = r * Math.sin(phi) * Math.sin(angle) * 0.3;
                particlesData[i].tz = r * Math.cos(phi);
            }
        }

        function calcTextTargets(text) {
            const c = document.createElement('canvas');
            const ctx = c.getContext('2d');
            c.width = 1024; c.height = 512;
            
            // ‚úÖ Ê∏ÖÊô∞Â∫¶‰ºòÂåñ1ÔºöÂ¢ûÂ§ßÂ≠óÂè∑ÔºåÂä†Á≤óÂ≠ó‰Ωì
            ctx.font = "900 150px 'Arial', sans-serif"; 
            ctx.fillStyle = "#fff";
            ctx.textAlign = "center"; ctx.textBaseline = "middle";
            ctx.fillText(text, c.width/2, c.height/2);
            
            const data = ctx.getImageData(0,0,c.width,c.height).data;
            let validPoints = [];
            
            // ‚úÖ Ê∏ÖÊô∞Â∫¶‰ºòÂåñ2ÔºöÈááÊ†∑Ê≠•Èïø‰ªé 4 ÈôçÂà∞ 3ÔºåËÆ©Á≤íÂ≠êÊõ¥Á¥ßÂáë
            const step = 3; 
            for(let y=0; y<c.height; y+=step) {
                for(let x=0; x<c.width; x+=step) {
                    if(data[(y*c.width+x)*4+3] > 128) {
                        validPoints.push({
                            x: (x - c.width/2) * 0.8,
                            // ‚úÖ Â±Ö‰∏≠‰øÆÊ≠£ÔºöÂéªÊéâ‰∫ÜÈ¢ùÂ§ñÁöÑ -50 ÂÅèÁßª
                            y: -(y - c.height/2) * 0.8
                        });
                    }
                }
            }

            for(let i=0; i<PARTICLE_COUNT; i++) {
                if(i < validPoints.length) {
                    const p = validPoints[i];
                    particlesData[i].tx = p.x;
                    particlesData[i].ty = p.y;
                    particlesData[i].tz = 0;
                } else {
                    const ang = Math.random()*Math.PI*2;
                    const r = 350 + Math.random()*100;
                    particlesData[i].tx = Math.cos(ang)*r;
                    particlesData[i].ty = (Math.random()-0.5)*400;
                    particlesData[i].tz = Math.sin(ang)*r;
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;
            
            const pos = particles.geometry.attributes.position.array;
            
            // ‚úÖ Ê∏ÖÊô∞Â∫¶‰ºòÂåñ3ÔºöÂ¶ÇÊûúÊòØÊñáÂ≠óÊ®°Âºè(isFist)ÔºåÂ§ßÂπÖÂáèÂ∞ëÁ≤íÂ≠êÊºÇÊµÆÊäñÂä® (0.5)ÔºåÂê¶ÂàôÂ§ßÂπÖÈ£òÂä® (5.0)
            const floatRange = isFist ? 0.5 : 5.0;

            for(let i=0; i<PARTICLE_COUNT; i++) {
                const d = particlesData[i];
                const idx = i*3;

                const targetX = d.tx + Math.sin(time + d.randomOffset)*floatRange;
                const targetY = d.ty + Math.cos(time + d.randomOffset)*floatRange;
                const targetZ = d.tz;

                pos[idx] += (targetX - pos[idx]) * d.speed;
                pos[idx+1] += (targetY - pos[idx+1]) * d.speed;
                pos[idx+2] += (targetZ - pos[idx+2]) * d.speed;

                if(!isFist) {
                    const x = pos[idx], z = pos[idx+2];
                    const rot = 0.0005;
                    pos[idx] = x*Math.cos(rot) - z*Math.sin(rot);
                    pos[idx+2] = z*Math.cos(rot) + x*Math.sin(rot);
                }
            }
            particles.geometry.attributes.position.needsUpdate = true;
            
            // ‚úÖ ÈúÄÊ±ÇÂÆûÁé∞ÔºöÁÖßÁâáÊòæÈöêÊéßÂà∂
            if(photoMesh) {
                photoMesh.visible = !isFist; // Êè°Êã≥(True) -> ÁÖßÁâáÈöêËóè(False)
                if(photoMesh.visible) {
                    photoMesh.lookAt(camera.position);
                    photoMesh.position.y = 20 + Math.sin(time)*3;
                }
            }

            composer.render();
        }

        async function startCameraAI() {
            const statusText = document.getElementById('status-text');
            const camDot = document.getElementById('cam-dot');
            const videoElement = document.querySelector('.input_video');

            if(typeof Hands === 'undefined') {
                statusText.innerText = "AI Â∫ìÂä†ËΩΩÂ§±Ë¥•";
                camDot.classList.add('error');
                return;
            }

            statusText.innerText = "ÂêØÂä®ÊëÑÂÉèÂ§¥...";
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
            hands.onResults(onHandsResults);

            try {
                const cameraUtils = new Camera(videoElement, {
                    onFrame: async () => await hands.send({image: videoElement}),
                    width: 640, height: 480
                });
                await cameraUtils.start();
                statusText.innerText = "‚úÖ ÊëÑÂÉèÂ§¥ËøêË°å‰∏≠";
                camDot.classList.add('active');
            } catch (error) {
                statusText.innerText = "Êó†Ê≥ïËÆøÈóÆÊëÑÂÉèÂ§¥";
                camDot.classList.add('error');
            }
        }

        function onHandsResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                detectGesture(landmarks);
            }
        }

        function detectGesture(landmarks) {
            const tips = [8, 12, 16, 20];
            const mcps = [5, 9, 13, 17]; 
            let foldedFingers = 0;
            const wrist = landmarks[0];
            
            for(let i=0; i<4; i++) {
                const tip = landmarks[tips[i]];
                const mcp = landmarks[mcps[i]];
                const dTip = Math.sqrt((tip.x-wrist.x)**2 + (tip.y-wrist.y)**2);
                const dMcp = Math.sqrt((mcp.x-wrist.x)**2 + (mcp.y-wrist.y)**2);
                if(dTip < dMcp * 1.1) foldedFingers++;
            }

            const currentIsFist = foldedFingers >= 3;

            if (currentIsFist !== isFist) {
                isFist = currentIsFist;
                const statusText = document.getElementById('status-text');
                if (isFist) {
                    statusText.innerText = "‚úä Êè°Êã≥ÔºöÊñáÂ≠óÊ®°Âºè";
                    calcTextTargets(document.getElementById('wish-text').value);
                } else {
                    statusText.innerText = "üñêÔ∏è Âº†ÂºÄÔºöÊòü‰∫ëÊ®°Âºè";
                    calcNebulaTargets();
                }
            }
        }

        document.getElementById('file-input').addEventListener('change', (e) => {
            const f = e.target.files[0];
            if(f) {
                const r = new FileReader();
                r.onload = (ev) => {
                    const img = new Image();
                    img.onload = () => {
                        if(photoMesh) scene.remove(photoMesh);
                        const tex = new THREE.Texture(img);
                        tex.needsUpdate = true;
                        tex.colorSpace = THREE.SRGBColorSpace;
                        const aspect = img.width/img.height;
                        let w=150, h=150; 
                        if(aspect>1) h=w/aspect; else w=h*aspect;
                        const geo = new THREE.PlaneGeometry(w,h);
                        const mat = new THREE.MeshBasicMaterial({
                            map: tex, side: THREE.DoubleSide, transparent: true,
                            color: new THREE.Color(0x999999)
                        });
                        photoMesh = new THREE.Mesh(geo, mat);
                        photoMesh.position.y = 20;
                        scene.add(photoMesh);
                    };
                    img.src = ev.target.result;
                };
                r.readAsDataURL(f);
            }
        });

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>

</html>
