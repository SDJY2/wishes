<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Magic Gift - Clear View</title>
    
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Noto+Serif+SC:wght@300;900&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Noto Serif SC', serif; user-select: none; -webkit-tap-highlight-color: transparent; }
        #canvas-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        .input_video { display: none; }

        #guide-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 999;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: white; text-align: center; transition: opacity 0.8s;
        }
        .title-box h1 { font-family: 'Cinzel', serif; font-weight: 400; letter-spacing: 5px; font-size: 28px; text-shadow: 0 0 30px rgba(255,215,0,0.6); margin: 0 0 10px 0; }
        .subtitle { font-size: 12px; color: #888; letter-spacing: 3px; margin-bottom: 50px; text-transform: uppercase; }
        #start-btn {
            padding: 14px 45px; font-size: 16px; letter-spacing: 2px;
            background: transparent; border: 1px solid rgba(255,255,255,0.4);
            border-radius: 50px; color: white; cursor: pointer; transition: all 0.3s;
            font-family: 'Cinzel', serif; box-shadow: 0 0 15px rgba(255,255,255,0.1);
        }
        
        #stage-tip {
            position: fixed; top: 15%; left: 0; width: 100%; text-align: center; z-index: 10;
            pointer-events: none; opacity: 0; transition: opacity 1s, transform 1s;
        }
        #stage-tip.active { opacity: 1; transform: translateY(0); }
        .tip-main { font-size: 24px; font-weight: 300; letter-spacing: 4px; color: #fff; text-shadow: 0 2px 10px rgba(0,0,0,0.8); margin-bottom: 8px; }
        .tip-sub { font-size: 14px; color: rgba(255,255,255,0.6); letter-spacing: 1px; font-family: sans-serif; }
        .skip-hint { position: fixed; bottom: 100px; width: 100%; text-align: center; color: #444; font-size: 12px; pointer-events: none; opacity: 0; transition: opacity 2s; z-index: 5; }

        .glass-btn {
            position: fixed; bottom: 30px; z-index: 50;
            background: rgba(30,30,35,0.7); color: #fff; border: 1px solid rgba(255,255,255,0.2);
            padding: 10px 20px; border-radius: 30px; font-size: 12px; cursor: pointer;
            backdrop-filter: blur(10px); box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            opacity: 0; pointer-events: none; transform: translateY(20px); transition: all 0.6s cubic-bezier(0.2, 0.8, 0.2, 1);
        }
        .glass-btn.show { opacity: 1; pointer-events: auto; transform: translateY(0); }
        #snap-btn { left: 20px; } #maker-btn { right: 20px; }

        #card-modal, #maker-panel { display: none; z-index: 1000; }
        #card-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(5, 5, 8, 0.98); flex-direction: column; justify-content: center; align-items: center; }
        .card-frame { width: 85%; max-width: 380px; border-radius: 12px; overflow: hidden; box-shadow: 0 0 60px rgba(0,0,0,0.8); border: 1px solid #333; position: relative; }
        #final-card-img { width: 100%; display: block; }
        .action-area { margin-top: 30px; display: flex; flex-direction: column; align-items: center; gap: 15px; }
        .save-btn { text-decoration: none; background: white; color: black; padding: 12px 35px; border-radius: 50px; font-weight: bold; font-size: 14px; box-shadow: 0 0 20px rgba(255,255,255,0.2); }

        #maker-panel { position: fixed; bottom: 80px; right: 20px; width: 260px; background: rgba(20, 20, 25, 0.95); border: 1px solid #444; border-radius: 16px; padding: 20px; color: white; box-shadow: 0 20px 60px rgba(0,0,0,0.8); }
        .input-box { width: 100%; padding: 10px; background: #2a2a2a; border: 1px solid #444; color: white; margin-top: 8px; box-sizing: border-box; border-radius: 6px; }
        .color-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin-top: 15px; }
        .color-item { padding-bottom: 100%; border-radius: 50%; cursor: pointer; border: 2px solid #333; transition: 0.2s; }
        .color-item.selected { border-color: #fff; transform: scale(1.15); box-shadow: 0 0 10px #fff; }
        #gen-btn { width: 100%; padding: 12px; margin-top: 20px; background: linear-gradient(90deg, #fff, #ddd); border: none; font-weight: bold; cursor: pointer; border-radius: 6px; }
    </style>
</head>
<body>

    <div id="guide-overlay">
        <div class="title-box"><h1>THE RITUAL</h1><p class="subtitle">Magic Gift Experience</p></div>
        <p style="color:#666; font-size:12px; margin-bottom:30px;">éœ€å…è®¸æ‘„åƒå¤´ä¸éº¦å…‹é£æƒé™</p>
        <button id="start-btn">å¼€å¯ä½“éªŒ</button>
    </div>

    <div id="stage-tip"><div class="tip-main" id="tip-main"></div><div class="tip-sub" id="tip-sub"></div></div>
    <div class="skip-hint" id="skip-hint">ï¼ˆå¦‚æœè¯†åˆ«å›°éš¾ï¼Œå¯ç‚¹å‡»å±å¹•å¼ºåˆ¶è§¦å‘ï¼‰</div>

    <div id="canvas-container"></div>
    <video class="input_video" playsinline webkit-playsinline muted></video>

    <div id="snap-btn" class="glass-btn">ğŸ“¸ ç”Ÿæˆçºªå¿µå¡</div>
    <div id="maker-btn" class="glass-btn">âœ¨ æˆ‘ä¹Ÿè¦å®šåˆ¶</div>

    <div id="card-modal">
        <div onclick="document.getElementById('card-modal').style.display='none'" style="position:absolute; top:30px; right:30px; color:white; font-size:30px; cursor:pointer;">âœ•</div>
        <div class="card-frame"><img id="final-card-img" src=""></div>
        <div class="action-area"><p style="color:#777; font-size:12px;">é•¿æŒ‰å›¾ç‰‡å³å¯ä¿å­˜åˆ°ç›¸å†Œ</p><a id="download-link" class="save-btn" href="#" download="MagicCard.png">ç›´æ¥ä¸‹è½½</a></div>
    </div>

    <div id="maker-panel">
        <div onclick="document.getElementById('maker-panel').style.display='none'" style="position:absolute; right:15px; top:15px; cursor:pointer; color:#888;">âœ•</div>
        <h4 style="margin:0; color:#ddd;">å®šåˆ¶ç¤¼ç‰©</h4>
        <input type="text" id="maker-from" class="input-box" placeholder="ä½ çš„åå­—">
        <input type="text" id="maker-text" class="input-box" placeholder="ç¥ç¦è¯­ (å¦‚: ç”Ÿæ—¥å¿«ä¹)">
        <div class="color-grid">
            <div class="color-item selected" style="background: linear-gradient(135deg, #00ffff, #ff00ff);" data-theme="cyber"></div>
            <div class="color-item" style="background: linear-gradient(135deg, #ffd700, #ff8c00);" data-theme="gold"></div>
            <div class="color-item" style="background: linear-gradient(135deg, #ff9a9e, #fecfef);" data-theme="sakura"></div>
            <div class="color-item" style="background: linear-gradient(135deg, #4facfe, #00f2fe);" data-theme="ocean"></div>
        </div>
        <button onclick="document.getElementById('img-upload').click()" class="input-box" style="margin-top:10px; cursor:pointer; text-align:center;">ğŸ“· ä¸Šä¼ ç…§ç‰‡</button>
        <input type="file" id="img-upload" style="display:none">
        <button id="gen-btn">å¤åˆ¶åˆ†äº«é“¾æ¥</button>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        const urlParams = new URLSearchParams(window.location.search);
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        const CONFIG = {
            photo: urlParams.get('img') || 'https://images.unsplash.com/photo-1518199266791-5375a83190b7?q=80&w=1000&auto=format&fit=crop',
            text: urlParams.get('text') || "2025 æœ‰ä½ \nå°±æ˜¯ç¤¼ç‰©",
            from: urlParams.get('from') || "ç¥ç§˜æœ‹å‹",
            theme: urlParams.get('theme') || 'cyber',
            particleCount: isMobile ? 12000 : 22000 
        };

        const THEMES = {
            'cyber': [new THREE.Color('#00ffff'), new THREE.Color('#ff00ff'), new THREE.Color('#ffffff')],
            'gold':  [new THREE.Color('#ffd700'), new THREE.Color('#ff8c00'), new THREE.Color('#fffaf0')],
            'sakura':[new THREE.Color('#ff9a9e'), new THREE.Color('#fecfef'), new THREE.Color('#fff')],
            'ocean': [new THREE.Color('#4facfe'), new THREE.Color('#00f2fe'), new THREE.Color('#f0f8ff')]
        };
        const currentPalette = THEMES[CONFIG.theme] || THEMES['cyber'];

        const STAGE = { IDLE: 0, WAIT_HAND: 1, WAIT_BLOW: 2, FORMING: 3, WAIT_PINCH: 4, WAIT_WAVE: 5, FINALE: 6 };
        let currentStage = STAGE.IDLE;
        let scene, camera, renderer, composer, particles, particleData = [];
        let targets = { photo: [], text: [] };
        let audioContext, analyser, dataArray;
        let handPos = { x: 0.5, y: 0.5 };
        let isHandPresent = false;
        let waveLastX = 0, time = 0, audioInit = false;
        let uploadedImgUrl = "";
        let photoMesh = null;

        const startBtn = document.getElementById('start-btn');
        startBtn.addEventListener('click', async () => {
            startBtn.innerText = "æ­£åœ¨åˆå§‹åŒ–...";
            startBtn.style.opacity = 0.7;
            try {
                await initAudio();
                initThree();
                await prepareTargets();
                await initCamera();
                document.getElementById('guide-overlay').style.opacity = 0;
                setTimeout(() => document.getElementById('guide-overlay').remove(), 1000);
                setTimeout(() => document.getElementById('skip-hint').style.opacity = 0.6, 3000);
                enterStage(STAGE.WAIT_HAND);
            } catch (e) {
                console.error(e);
                alert("åˆå§‹åŒ–å¤±è´¥ï¼Œè¯·é‡è¯•ã€‚");
            }
        });

        function enterStage(s) {
            currentStage = s;
            const tipBox = document.getElementById('stage-tip');
            const main = document.getElementById('tip-main');
            const sub = document.getElementById('tip-sub');
            tipBox.classList.remove('active');
            setTimeout(() => {
                switch(s) {
                    case STAGE.WAIT_HAND: main.innerText = "å¼ å¼€æ‰‹æŒ"; sub.innerText = `å‡†å¤‡æ¥ä½ ${decodeURIComponent(CONFIG.from)} çš„ç¤¼ç‰©`; break;
                    case STAGE.WAIT_BLOW: main.innerText = "å¹ä¸€å£æ°”"; sub.innerText = "å”¤é†’æ²‰ç¡çš„æ˜Ÿå°˜"; break;
                    case STAGE.WAIT_PINCH: main.innerText = "è½»è½»æåˆ"; sub.innerText = "å°†ç¤¼ç‰©æ‹‰å…¥ç°å®"; break;
                    case STAGE.WAIT_WAVE: main.innerText = "æŒ¥æŒ¥æ‰‹"; sub.innerText = "ç‚¹äº®æœ€åçš„ç¥ç¦"; break;
                    case STAGE.FINALE: 
                        main.innerText = ""; sub.innerText = "";
                        document.getElementById('snap-btn').classList.add('show');
                        document.getElementById('maker-btn').classList.add('show');
                        document.getElementById('skip-hint').style.display = 'none';
                        break;
                }
                if (s !== STAGE.FORMING && s !== STAGE.FINALE) tipBox.classList.add('active');
            }, 600);
        }

        document.addEventListener('click', (e) => {
            if(e.target.closest('button') || e.target.closest('.glass-btn') || e.target.closest('#maker-panel') || e.target.closest('#card-modal')) return;
            if(currentStage === STAGE.WAIT_HAND) triggerPalmOpen();
            else if(currentStage === STAGE.WAIT_BLOW) triggerBlowEffect();
            else if(currentStage === STAGE.WAIT_PINCH) triggerPinch();
            else if(currentStage === STAGE.WAIT_WAVE) triggerWave();
        });

        function triggerPalmOpen() {
            for(let i=0; i<CONFIG.particleCount; i++) {
                const p = particleData[i];
                p.x = (Math.random()-0.5)*50; p.y = -50 + (Math.random()-0.5)*50; p.z = 0;
                p.tx = (Math.random()-0.5) * 600; p.ty = 300 + Math.random() * 300; p.tz = (Math.random()-0.5) * 300;
                p.speed = 0.06 + Math.random() * 0.04;
            }
            enterStage(STAGE.WAIT_BLOW);
        }

        function checkBlow() {
            if(!audioInit || !analyser || currentStage !== STAGE.WAIT_BLOW) return;
            analyser.getByteFrequencyData(dataArray);
            let sum = 0; for(let i=0; i<15; i++) sum += dataArray[i];
            if (sum/15 > 35) triggerBlowEffect();
        }

        function triggerBlowEffect() {
            currentStage = STAGE.FORMING;
            document.getElementById('stage-tip').classList.remove('active');
            particleData.forEach(p => {
                const angle = Math.random() * Math.PI * 2; const r = 400 + Math.random() * 200;
                p.tx = Math.cos(angle) * r; p.ty = Math.sin(angle) * r; p.tz = (Math.random()-0.5) * 600;
                p.speed = 0.08;
            });
            setTimeout(() => {
                const count = Math.min(CONFIG.particleCount, targets.photo.length);
                for(let i=0; i<CONFIG.particleCount; i++) {
                    const p = particleData[i];
                    if(i < count) {
                        const t = targets.photo[i];
                        p.tx = t.x; p.ty = t.y; p.tz = 0;
                        p.speed = 0.025; 
                        p.mode = 'photo';
                        p.photoColor = t.color; 
                    } else {
                        p.tx = (Math.random()-0.5) * 900; p.ty = (Math.random()-0.5) * 900; p.tz = -200 + (Math.random()-0.5) * 200;
                        p.speed = 0.01;
                    }
                }
            }, 1200);
            setTimeout(() => enterStage(STAGE.WAIT_PINCH), 3500);
        }

        function triggerPinch() {
            particleData.forEach(p => {
                if(p.mode === 'photo') {
                    p.speed = 0.15;
                    p.color.setHex(0xffffff);
                }
            });
            
            // ğŸ”¥ é™ä½è¾‰å…‰å¼ºåº¦ï¼Œé˜²æ­¢è¿‡æ›
            const bloom = composer.passes[1]; 
            bloom.strength = 1.0; 
            
            if(photoMesh) {
                let opacity = 0;
                let fadeIn = setInterval(() => {
                    opacity += 0.05;
                    if(photoMesh.material.opacity < 1) {
                        photoMesh.material.opacity = opacity;
                    } else {
                        clearInterval(fadeIn);
                    }
                }, 30);
            }

            enterStage(STAGE.WAIT_WAVE);
        }

        function triggerWave() {
            if(photoMesh) {
                let fadeOut = setInterval(() => {
                    photoMesh.material.opacity -= 0.1;
                    if(photoMesh.material.opacity <= 0) {
                        photoMesh.visible = false;
                        clearInterval(fadeOut);
                    }
                }, 30);
            }

            const count = Math.min(CONFIG.particleCount, targets.text.length);
            for(let i=0; i<CONFIG.particleCount; i++) {
                const p = particleData[i];
                p.x += (Math.random()-0.5) * 100;
                if(i < count) {
                    p.tx = targets.text[i].x; p.ty = targets.text[i].y; p.tz = 0;
                    p.speed = 0.05; p.mode = 'text';
                    p.baseColor = new THREE.Color(0xffffff); 
                } else {
                    p.tx = (Math.random()-0.5) * 1000; p.ty = (Math.random()-0.5) * 1000; p.tz = (Math.random()-0.5) * 600;
                    p.speed = 0.02; p.mode = 'bg';
                }
            }
            enterStage(STAGE.FINALE);
        }

        function initThree() {
            scene = new THREE.Scene(); scene.fog = new THREE.FogExp2(0x000000, 0.0012); 
            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 3000); 
            camera.position.z = isMobile ? 650 : 550;

            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance", preserveDrawingBuffer: true });
            renderer.setSize(window.innerWidth, window.innerHeight); 
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            
            // ğŸ”¥ å…³é”®ä¿®å¤ï¼šå¼€å¯ ToneMapping é˜²æ­¢é«˜å…‰æº¢å‡º
            renderer.toneMapping = THREE.ReinhardToneMapping;
            renderer.toneMappingExposure = 1.5;

            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            const renderPass = new RenderPass(scene, camera);
            
            // ğŸ”¥ å…³é”®ä¿®å¤ï¼šé˜ˆå€¼è®¾ä¸º 0.15 (åªæœ‰äº®å¤„å‘å…‰)ï¼Œå¼ºåº¦é™ä¸º 1.0 (æŸ”å’Œå…‰æ™•)
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.65);
            bloomPass.threshold = 0.15; 
            bloomPass.strength = 1.0; 
            bloomPass.radius = 0.4;
            
            composer = new EffectComposer(renderer); composer.addPass(renderPass); composer.addPass(bloomPass);
            initParticles(); animate();
            window.addEventListener('resize', () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight); });
        }

        function createSparkTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 32, 32);
            return new THREE.CanvasTexture(canvas);
        }

        function initParticles() {
            const geo = new THREE.BufferGeometry();
            const pos = [], cols = [], sizes = [];
            const tex = createSparkTexture();

            for(let i=0; i<CONFIG.particleCount; i++) {
                const x = (Math.random()-0.5)*50; const y = -300+(Math.random()-0.5)*20; const z = (Math.random()-0.5)*50;
                pos.push(x, y, z);
                const c = currentPalette[Math.floor(Math.random()*currentPalette.length)];
                cols.push(c.r, c.g, c.b);
                sizes.push(Math.random() * (isMobile ? 8 : 6) + 2);
                particleData.push({
                    x:x, y:y, z:z, tx:x, ty:y, tz:z, speed: 0.02,
                    baseColor: c, color: c.clone(), mode: 'idle', angle: Math.random()*Math.PI*2,
                    photoColor: new THREE.Color()
                });
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            geo.setAttribute('color', new THREE.Float32BufferAttribute(cols, 3));
            geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            const mat = new THREE.PointsMaterial({ 
                size: isMobile ? 8 : 6, 
                map: tex, 
                vertexColors: true, 
                blending: THREE.AdditiveBlending, 
                depthWrite: false, 
                transparent: true, 
                opacity: 0.85 
            });
            particles = new THREE.Points(geo, mat);
            scene.add(particles);
        }

        async function prepareTargets() {
            const img = new Image(); img.crossOrigin = "Anonymous"; img.src = CONFIG.photo;
            await new Promise(r => { img.onload = r; img.onerror = r; });
            const c = document.createElement('canvas'); const ctx = c.getContext('2d');
            
            const aspect = img.width / img.height;
            let targetW, targetH;
            
            const MAX_3D_SIZE = 900; 
            if(aspect >= 1) { targetW = MAX_3D_SIZE; targetH = MAX_3D_SIZE / aspect; } 
            else { targetH = MAX_3D_SIZE; targetW = MAX_3D_SIZE * aspect; }

            const tex = new THREE.TextureLoader().load(CONFIG.photo);
            tex.colorSpace = THREE.SRGBColorSpace;
            const photoGeo = new THREE.PlaneGeometry(targetW, targetH);
            
            // ğŸ”¥ å…³é”®ä¿®å¤ï¼šç…§ç‰‡æè´¨é¢œè‰²è®¾ä¸ºç°è‰² (0xaaaaaa)ï¼Œé™ä½è‡ªèº«äº®åº¦
            const photoMat = new THREE.MeshBasicMaterial({ 
                map: tex, 
                transparent: true, 
                opacity: 0, 
                side: THREE.DoubleSide, 
                color: 0xaaaaaa 
            });
            
            photoMesh = new THREE.Mesh(photoGeo, photoMat);
            photoMesh.position.z = -2; 
            scene.add(photoMesh);

            const size = 250; 
            c.width = size; c.height = size / aspect;
            ctx.drawImage(img, 0, 0, c.width, c.height);
            const imgData = ctx.getImageData(0, 0, c.width, c.height).data;
            
            for(let y=0; y<c.height; y++) {
                for(let x=0; x<c.width; x++) {
                    const i = (y*c.width + x) * 4;
                    if(imgData[i+3] > 80) { 
                        targets.photo.push({
                            x: (x/c.width - 0.5) * targetW,
                            y: -(y/c.height - 0.5) * targetH,
                            color: new THREE.Color(`rgb(${imgData[i]},${imgData[i+1]},${imgData[i+2]})`)
                        });
                    }
                }
            }

            ctx.clearRect(0,0,c.width,c.height); c.width = 1024; c.height = 512;
            ctx.font = "600 100px 'Noto Serif SC', sans-serif"; 
            ctx.fillStyle = "white"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
            decodeURIComponent(CONFIG.text).split('\\n').forEach((line, i) => ctx.fillText(line, 512, 256 + i*150));
            
            const txtData = ctx.getImageData(0,0,1024,512).data;
            const step = 2; 
            for(let y=0; y<512; y+=step) {
                for(let x=0; x<1024; x+=step) {
                    if(txtData[(y*1024+x)*4+3] > 100) {
                        targets.text.push({ x: (x - 512) * 1.0, y: -(y - 256) * 1.0 });
                    }
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate); time += 0.015; checkBlow();
            const pos = particles.geometry.attributes.position.array;
            const cols = particles.geometry.attributes.color.array;
            for(let i=0; i<CONFIG.particleCount; i++) {
                const p = particleData[i]; const ix = i*3;
                let tx = p.tx, ty = p.ty, tz = p.tz;
                if(p.mode === 'photo' || p.mode === 'text') {
                    if(!photoMesh || photoMesh.material.opacity < 0.5) {
                        tx += Math.sin(time + p.angle) * 3; ty += Math.cos(time + p.angle) * 3;
                        if(isHandPresent) { tx += (handPos.x - 0.5) * 40; ty -= (handPos.y - 0.5) * 40; }
                    }
                }
                p.x += (tx - p.x) * p.speed; p.y += (ty - p.y) * p.speed; p.z += (tz - p.z) * p.speed;
                
                if(p.mode === 'photo') {
                    p.color.lerp(p.photoColor, 0.08); 
                } else if (p.mode === 'text') {
                    p.color.lerp(p.baseColor, 0.1); 
                } else {
                    p.color.lerp(p.baseColor, 0.05); 
                }

                pos[ix] = p.x; pos[ix+1] = p.y; pos[ix+2] = p.z;
                cols[ix] = p.color.r; cols[ix+1] = p.color.g; cols[ix+2] = p.color.b;
            }
            particles.geometry.attributes.position.needsUpdate = true;
            particles.geometry.attributes.color.needsUpdate = true;
            
            if(photoMesh && isHandPresent) {
                photoMesh.position.x += ((handPos.x - 0.5)*20 - photoMesh.position.x) * 0.1;
                photoMesh.position.y += (-(handPos.y - 0.5)*20 - photoMesh.position.y) * 0.1;
            }

            composer.render();
        }

        async function initAudio() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                const source = audioContext.createMediaStreamSource(stream);
                source.connect(analyser); analyser.fftSize = 256; dataArray = new Uint8Array(analyser.frequencyBinCount); audioInit = true;
            } catch(e) { console.warn("Audio init failed:", e); }
        }

        async function initCamera() {
            const video = document.querySelector('.input_video');
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
            hands.onResults(results => {
                if(results.multiHandLandmarks.length > 0) {
                    isHandPresent = true; const lm = results.multiHandLandmarks[0];
                    handPos.x = lm[0].x; handPos.y = lm[0].y;
                    const wrist = lm[0];
                    let extendedFingers = 0;
                    [8, 12, 16, 20].forEach(idx => {
                        const dist = Math.sqrt((lm[idx].x - wrist.x)**2 + (lm[idx].y - wrist.y)**2);
                        if(dist > 0.18) extendedFingers++;
                    });
                    if(currentStage === STAGE.WAIT_HAND && extendedFingers >= 3) triggerPalmOpen();
                    const pinchDist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                    if(currentStage === STAGE.WAIT_PINCH && pinchDist < 0.06) triggerPinch();
                    const vx = lm[0].x - waveLastX;
                    if(currentStage === STAGE.WAIT_WAVE && Math.abs(vx) > 0.05) triggerWave();
                    waveLastX = lm[0].x;
                } else isHandPresent = false;
            });
            const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' } });
            video.srcObject = stream;
            video.onloadedmetadata = () => {
                video.play();
                new Camera(video, { onFrame: async () => await hands.send({image: video}), width: 640, height: 480 }).start();
            };
        }

        document.getElementById('snap-btn').onclick = () => {
            const canvas = document.createElement('canvas'); const w = 1080, h = 1920; canvas.width = w; canvas.height = h; const ctx = canvas.getContext('2d');
            const grad = ctx.createLinearGradient(0, 0, 0, h); grad.addColorStop(0, "#050510"); grad.addColorStop(1, "#1e1b2e"); ctx.fillStyle = grad; ctx.fillRect(0,0,w,h);
            const src = renderer.domElement; const sSize = Math.min(src.width, src.height); const dSize = 900; const dx = (w - dSize)/2, dy = 350;
            ctx.save(); ctx.beginPath(); ctx.roundRect(dx, dy, dSize, dSize, 40); ctx.clip(); ctx.fillStyle = "black"; ctx.fillRect(dx,dy,dSize,dSize);
            ctx.drawImage(src, (src.width-sSize)/2, (src.height-sSize)/2, sSize, sSize, dx, dy, dSize, dSize); ctx.restore();
            ctx.strokeStyle = "rgba(255, 215, 0, 0.4)"; ctx.lineWidth = 5; ctx.beginPath(); ctx.roundRect(dx, dy, dSize, dSize, 40); ctx.stroke();
            ctx.textAlign = "center"; ctx.fillStyle = "#fff"; ctx.font = "bold 90px 'Noto Serif SC', serif"; ctx.shadowColor = "rgba(255,255,255,0.5)"; ctx.shadowBlur = 20;
            ctx.fillText(decodeURIComponent(CONFIG.text).split('\\n')[0], w/2, dy + dSize + 160);
            ctx.shadowBlur = 0; ctx.font = "40px sans-serif"; ctx.fillStyle = "#888"; ctx.fillText(`From ${decodeURIComponent(CONFIG.from)}`, w/2, dy + dSize + 260);
            document.getElementById('final-card-img').src = canvas.toDataURL("image/png"); document.getElementById('download-link').href = canvas.toDataURL("image/png"); document.getElementById('card-modal').style.display = 'flex';
        };

        document.getElementById('maker-btn').onclick = () => document.getElementById('maker-panel').style.display = 'block';
        let selectedTheme = CONFIG.theme;
        document.querySelectorAll('.color-item').forEach(item => { item.onclick = (e) => { document.querySelectorAll('.color-item').forEach(i => i.classList.remove('selected')); e.target.classList.add('selected'); selectedTheme = e.target.dataset.theme; }});
        const IMGBB_KEY = '486b3dbcc415576a5112c1937d31f9b1'; 
        document.getElementById('img-upload').onchange = async (e) => {
            const file = e.target.files[0]; if(!file) return; const btn = e.target.previousElementSibling; btn.innerText = "â³ ä¸Šä¼ ä¸­...";
            const fd = new FormData(); fd.append("image", file);
            try { const res = await (await fetch(`https://api.imgbb.com/1/upload?key=${IMGBB_KEY}`, { method: "POST", body: fd })).json(); if(res.success) { uploadedImgUrl = res.data.url; btn.innerText = "âœ… ä¸Šä¼ æˆåŠŸ"; } } catch(err) { btn.innerText = "âŒ å¤±è´¥"; }
        };
        document.getElementById('gen-btn').onclick = () => {
            let url = `${window.location.origin}${window.location.pathname}?theme=${selectedTheme}`;
            const txt = document.getElementById('maker-text').value.trim(); const frm = document.getElementById('maker-from').value.trim();
            if(txt) url += `&text=${encodeURIComponent(txt)}`; if(frm) url += `&from=${encodeURIComponent(frm)}`; if(uploadedImgUrl) url += `&img=${encodeURIComponent(uploadedImgUrl)}`;
            navigator.clipboard.writeText(url).then(() => alert("é“¾æ¥å·²å¤åˆ¶ï¼\nå‘é€ç»™æœ‹å‹ï¼Œç»™TAä¸€ä¸ªæƒŠå–œå§ï¼"));
        };
    </script>
</body>
</html>
